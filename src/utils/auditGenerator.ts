import { AuditResult } from '../types/audit';
import { OpenAIClient } from './openaiClient';

// Fallback data for when API is not available
const generateFallbackAudit = async (
  websiteUrl: string,
  websiteType: string,
  targetMarket: string,
  mode: string,
  onProgress: (message: string, progress?: number) => void
): Promise<AuditResult> => {
  // Simulate progressive analysis
  onProgress('Analyzing homepage structure...', 10);
  await new Promise(resolve => setTimeout(resolve, 800));

  onProgress('Evaluating navigation and user flow...', 30);
  await new Promise(resolve => setTimeout(resolve, 600));

  onProgress('Reviewing conversion funnels...', 50);
  await new Promise(resolve => setTimeout(resolve, 700));

  onProgress('Assessing mobile experience...', 70);
  await new Promise(resolve => setTimeout(resolve, 500));

  onProgress('Generating recommendations...', 90);
  await new Promise(resolve => setTimeout(resolve, 400));

  // Return basic fallback audit
  const fallbackResult: AuditResult = {
    id: Date.now().toString(),
    websiteUrl,
    websiteType,
    targetMarket,
    mode,
    recommendations: [
      {
        id: 'fallback-1',
        observation: 'API key not configured - showing demo recommendations',
        strengths: 'Clean website structure',
        suggestedImprovement: 'Configure your OpenAI API key to get real, personalized audit recommendations',
        impact: 'High' as const,
        effort: 'Low' as const,
        section: 'Homepage',
        pageType: 'Homepage'
      }
    ],
    quickWins: [
      {
        id: 'qw-fallback-1',
        change: 'Configure OpenAI API key for real recommendations',
        effort: 'Low' as const,
        impact: 'High' as const,
        priority: 'High' as const
      }
    ],
    abTests: [
      {
        id: 'ab-fallback-1',
        testName: 'API Integration Test',
        frictionPoint: 'Missing personalized recommendations',
        expectedLift: '100% improvement in audit quality',
        description: 'Add your OpenAI API key to get real, contextual CRO recommendations'
      }
    ],
    introduction: `# Demo Mode - Configure API Key for Real Audits

This is a demonstration of the CRO Audit Tool. To get real, personalized recommendations for **${websiteUrl}**, please configure your OpenAI API key using the settings button in the header.

With a valid API key, you'll receive:
- Comprehensive Team Analysis (Strategist, Psychologist, UX, Copywriter)
- Granular Heuristic Audit (7-Point Framework)
- 15-25 specific, actionable recommendations
- High-Fidelity Mock Designs generated by AI
- Analysis tailored to your ${websiteType.toLowerCase()} website and ${targetMarket} market`,
    generatedAt: Date.now(),
    heuristicAnalysis: [
        {
            category: "1. Orient Upon Entrance",
            items: [
                { question: "Does the header clear explain the product?", score: 1, observation: "Header is vague ('Welcome to Future').", recommendation: "Change H1 to specific value prop." },
                { question: "Is the audience clear?", score: 2, observation: "Mentions 'businesses' but not specific size/industry.", recommendation: "Specify 'For Enterprise SaaS'." }
            ]
        },
        {
            category: "4. Reduce Anxiety",
            items: [
                { question: "Are trust signals visible?", score: 0, observation: "No logos or testimonials above fold.", recommendation: "Add 'Trusted by' strip." }
            ]
        }
    ]
  };

  onProgress('Analysis Complete', 100);
  return fallbackResult;
};

// Helper to fetch website content (simulate backend scraping via CORS proxy)
const fetchWebsiteContent = async (url: string): Promise<string> => {
  try {
      // Using a public CORS proxy is a common workaround for client-side demos.
      // In production, this should be a backend service.
      const proxyUrl = `https://api.allorigins.win/get?url=${encodeURIComponent(url)}`;
      const response = await fetch(proxyUrl);
      const data = await response.json();

      if (!data.contents) return "";

      // Simple text extraction from HTML to pass to LLM
      const parser = new DOMParser();
      const doc = parser.parseFromString(data.contents, 'text/html');

      // Extract main meaningful text
      const bodyText = doc.body.innerText || "";
      // Clean up whitespace
      return bodyText.replace(/\s+/g, ' ').substring(0, 15000); // Limit to ~15k chars for token limits
  } catch (e) {
      console.warn("Failed to fetch website content via proxy, falling back to URL-only analysis", e);
      return "";
  }
};

export const generateAudit = async (
  websiteUrl: string,
  websiteType: string,
  targetMarket: string,
  mode: string,
  onProgress: (message: string, progress?: number) => void,
  apiKey?: string
): Promise<AuditResult> => {
  if (!apiKey) {
    return generateFallbackAudit(websiteUrl, websiteType, targetMarket, mode, onProgress);
  }

  // Fetch website content for analysis
  onProgress('Fetching website content...', 10);
  const websiteContent = await fetchWebsiteContent(websiteUrl);

  // Define the analysis steps
  const analysisSteps = [
      "1. Orient Upon Entrance (H1, Message Match)...",
      "2. Minimize Distraction (Layout, Links)...",
      "3. Value Proposition (Why Us?)...",
      "4. Reduce Anxiety (Trust, Proof)...",
      "5. Make it Easy (UX, CTA)...",
      "6. Pricing & Offer Analysis...",
      "7. Copywriting & Tone Check..."
  ];

  let stepIndex = 0;
  // Initial message
  onProgress("Initializing Expert Team...", 20);

  // Start cycling through steps every 5 seconds
  const progressInterval = setInterval(() => {
      if (stepIndex < analysisSteps.length) {
          // Calculate progress from 20% to 90%
          const percentage = 20 + ((stepIndex / analysisSteps.length) * 70);
          onProgress(`Analyzing Pillar: ${analysisSteps[stepIndex]}`, Math.round(percentage));
          stepIndex++;
      } else {
          onProgress("Finalizing Recommendations & Report...", 95);
      }
  }, 4000);

  try {
    const client = new OpenAIClient(apiKey);
    const result = await client.generateAudit(websiteUrl, websiteType, targetMarket, mode, (msg) => {
        // Optional: Ignore internal client messages in favor of our high-level cycling
        // or log them if needed. For now, let's keep our high-level UI messages dominating
        // unless the client sends something critical (which it currently calls 'Conducting expert analysis...' once)
        console.log("Client progress:", msg);
    }, websiteContent);

    clearInterval(progressInterval);
    onProgress('Audit Completed Successfully', 100);
    return result;
  } catch (error) {
    clearInterval(progressInterval);
    console.error('Failed to generate audit with OpenAI:', error);
    throw error;
  }
};

export const generateMockup = async (
    auditResult: AuditResult,
    onProgress: (message: string) => void,
    apiKey?: string
): Promise<string> => {
    if (!apiKey) {
        return `<div style="display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100%; color: #94A3B8; font-family: sans-serif;">
        <h2 style="font-size: 2rem; margin-bottom: 1rem; color: #F8FAFC;">Demo Design Placeholder</h2>
        <p>Please configure your OpenAI API Key to generate a full high-fidelity mock design.</p>
      </div>`;
    }
    const client = new OpenAIClient(apiKey);
    return await client.generateMockup(auditResult, onProgress);
}
